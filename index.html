<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Towers of Hanoi - Terminal Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #0a0a0a;
            color: #00ff00;
            font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Consolas, 'DejaVu Sans Mono', monospace;
            padding: 30px 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        h1 {
            font-size: 1.8em;
            text-shadow: 0 0 3px #00ff00;
            margin-bottom: 15px;
            letter-spacing: 2px;
        }

        .header {
            display: flex;
            gap: 40px;
            margin-bottom: 25px;
            font-size: 0.95em;
            text-shadow: 0 0 5px #00ff00;
        }

        .game-board {
            display: flex;
            gap: 60px;
            margin-bottom: 25px;
            min-height: 400px;
        }

        .tower {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .tower-label {
            font-size: 0.85em;
            margin-bottom: 5px;
            text-shadow: 0 0 5px #00ff00;
            opacity: 0.8;
        }

        .tower.selected .tower-label {
            color: #00ff00;
            text-shadow: 0 0 15px #00ff00, 0 0 25px #00ff00;
            font-weight: bold;
            opacity: 1;
        }

        .pole-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 20px;
            line-height: 1.1;
            white-space: pre;
        }

        .ascii-tower {
            text-align: center;
            text-shadow: 0 0 5px #00ff00;
            padding: 10px;
            background-color: rgba(0, 255, 0, 0.02);
            border-radius: 4px;
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
        }

        button {
            background-color: #0a0a0a;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 8px 16px;
            font-family: inherit;
            font-size: 0.85em;
            cursor: pointer;
            text-shadow: 0 0 5px #00ff00;
            box-shadow: 0 0 5px #00ff00;
            transition: all 0.2s;
        }

        button:hover {
            background-color: #00ff00;
            color: #0a0a0a;
            text-shadow: none;
            box-shadow: 0 0 10px #00ff00;
        }

        .disk-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .disk-count-display {
            min-width: 30px;
            text-align: center;
            font-size: 0.85em;
            text-shadow: 0 0 5px #00ff00;
        }

        button.small {
            padding: 4px 10px;
            font-size: 0.9em;
            min-width: 30px;
        }

        label {
            text-shadow: 0 0 5px #00ff00;
            font-size: 0.85em;
        }

        .message {
            min-height: 25px;
            font-size: 0.9em;
            text-align: center;
            text-shadow: 0 0 5px #00ff00;
            margin-bottom: 20px;
        }

        .message.error {
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000;
        }

        .message.win {
            color: #ffff00;
            text-shadow: 0 0 15px #ffff00, 0 0 25px #ffff00;
            font-size: 1.2em;
            font-weight: bold;
        }

        .instructions {
            text-align: center;
            font-size: 0.8em;
            text-shadow: 0 0 3px #00ff00;
            opacity: 0.7;
            max-width: 600px;
        }

        .high-score-section {
            margin: 20px 0;
            text-align: center;
        }

        .high-score-header {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .high-score-board {
            display: inline-block;
            text-align: left;
            font-size: 0.75em;
            line-height: 1.3;
            text-shadow: 0 0 5px #00ff00;
            padding: 10px;
            background-color: rgba(0, 255, 0, 0.02);
            border-radius: 4px;
            margin: 0;
        }

        .high-score-board.hidden {
            display: none;
        }

        .high-score-board .perfect-score {
            color: #00ffff;
            text-shadow: 0 0 8px #00ffff;
        }

        .message.record {
            color: #ffff00;
            text-shadow: 0 0 10px #ffff00;
            font-weight: bold;
        }

        .message.perfect {
            color: #00ffff;
            text-shadow: 0 0 15px #00ffff, 0 0 25px #00ffff;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Towers of Hanoi</h1>

    <div class="header">
        <div id="timer">TIME: 00:00</div>
        <div id="moveCounter">MOVES: 0</div>
    </div>

    <div class="game-board">
        <div class="tower" data-tower="0">
            <div class="tower-label">[1]</div>
            <div class="pole-container">
                <div class="ascii-tower"></div>
            </div>
        </div>

        <div class="tower" data-tower="1">
            <div class="tower-label">[2]</div>
            <div class="pole-container">
                <div class="ascii-tower"></div>
            </div>
        </div>

        <div class="tower" data-tower="2">
            <div class="tower-label">[3]</div>
            <div class="pole-container">
                <div class="ascii-tower"></div>
            </div>
        </div>
    </div>

    <div class="message" id="message">Press 1, 2, or 3 to select a tower</div>

    <div class="controls">
        <label>Disks:</label>
        <div class="disk-controls">
            <button id="decrementBtn" class="small">-</button>
            <div class="disk-count-display" id="diskCountDisplay">5</div>
            <button id="incrementBtn" class="small">+</button>
        </div>
        <button id="newGameBtn">New Game</button>
    </div>

    <div class="high-score-section">
        <div class="high-score-header">
            <span>HIGH SCORES</span>
            <button id="toggleScoresBtn" class="small">Hide [H]</button>
            <button id="clearScoresBtn" class="small">Clear</button>
        </div>
        <pre id="highScoreBoard" class="high-score-board"></pre>
    </div>

    <div class="instructions">
        Move all disks from Tower 1 to Tower 3.<br>
        Only smaller disks can be placed on larger disks.<br>
        Press 'N' for new game • '+/-' to change disk count • 'H' to toggle high scores
    </div>

    <script>
        // Game state - stores all game data
        let gameState = {
            towers: [[], [], []],     // Arrays holding disk sizes for each tower
            selectedTower: null,      // Currently selected tower (null or 0-2)
            moveCount: 0,
            startTime: null,          // When the timer started
            timerInterval: null,      // setInterval reference
            diskCount: 5,
            gameWon: false
        };

        // Selected disk count for next game (separate from current game)
        let selectedDiskCount = 5;

        // Load high scores from localStorage
        function loadHighScores() {
            try {
                const stored = localStorage.getItem('hanoi_highscores');
                return stored ? JSON.parse(stored) : {};
            } catch (e) {
                // localStorage disabled or data corrupted
                console.warn('Could not load high scores:', e);
                return {};
            }
        }

        // Save high scores to localStorage
        function saveHighScores(scores) {
            try {
                localStorage.setItem('hanoi_highscores', JSON.stringify(scores));
            } catch (e) {
                // localStorage disabled or full
                console.warn('Could not save high scores:', e);
            }
        }

        // Get minimal possible moves for disk count
        function getMinimalMoves(diskCount) {
            return Math.pow(2, diskCount) - 1;
        }

        // Check if current game is a new record and save if so
        // Returns: { type: 'none' | 'first' | 'moves' | 'time' | 'perfect', isPerfect: boolean }
        function checkAndSaveHighScore(diskCount, moves, timeSeconds) {
            const scores = loadHighScores();
            const key = String(diskCount);
            const minMoves = getMinimalMoves(diskCount);
            const isPerfect = moves === minMoves;

            let recordType = 'none';

            if (!scores[key]) {
                // First completion for this disk count
                scores[key] = { moves: moves, time: timeSeconds, timestamp: Date.now() };
                recordType = isPerfect ? 'perfect' : 'first';
            } else {
                // Better move count (primary metric)
                if (moves < scores[key].moves) {
                    scores[key].moves = moves;
                    scores[key].time = timeSeconds;
                    scores[key].timestamp = Date.now();
                    recordType = isPerfect ? 'perfect' : 'moves';
                }
                // Same move count but better time (tiebreaker)
                else if (moves === scores[key].moves && timeSeconds < scores[key].time) {
                    scores[key].time = timeSeconds;
                    scores[key].timestamp = Date.now();
                    recordType = 'time';
                }
            }

            if (recordType !== 'none') {
                saveHighScores(scores);
                renderHighScores();
            }

            return { type: recordType, isPerfect: isPerfect };
        }

        // Render high score board as ASCII table
        function renderHighScores() {
            const scores = loadHighScores();
            const container = document.getElementById('highScoreBoard');

            if (!container) return;

            const lines = [];

            // Header
            lines.push('┌───────┬───────────┬───────────┬────────────┐');
            lines.push('│ DISKS │ MIN MOVES │ YOUR BEST │    TIME    │');
            lines.push('├───────┼───────────┼───────────┼────────────┤');

            // Rows for disk counts 3-10
            for (let diskCount = 3; diskCount <= 10; diskCount++) {
                const minMoves = getMinimalMoves(diskCount);
                const score = scores[String(diskCount)];

                let bestMoves = '--';
                let bestTime = '--';
                let rowClass = '';

                if (score) {
                    bestMoves = String(score.moves).padStart(2, ' ');
                    const minutes = String(Math.floor(score.time / 60)).padStart(2, '0');
                    const seconds = String(score.time % 60).padStart(2, '0');
                    bestTime = `${minutes}:${seconds}`;

                    // Highlight perfect scores
                    if (score.moves === minMoves) {
                        rowClass = 'perfect-score';
                    }
                }

                const diskStr = String(diskCount).padStart(3, ' ');
                const minStr = String(minMoves).padStart(5, ' ');
                const bestStr = String(bestMoves).padStart(5, ' ');
                const timeStr = String(bestTime).padStart(6, ' ');

                let row = `│  ${diskStr}  │   ${minStr}   │   ${bestStr}   │   ${timeStr}   │`;

                if (rowClass) {
                    // Mark perfect scores with special indicator
                    row = `<span class="${rowClass}">${row}</span>`;
                }

                lines.push(row);
            }

            // Footer
            lines.push('└───────┴───────────┴───────────┴────────────┘');

            container.innerHTML = lines.join('\n');
        }

        // Clear all high scores (with confirmation)
        function clearHighScores() {
            if (confirm('Clear all high scores? This cannot be undone.')) {
                try {
                    localStorage.removeItem('hanoi_highscores');
                    renderHighScores();
                    showMessage('High scores cleared');
                } catch (e) {
                    console.warn('Could not clear high scores:', e);
                }
            }
        }

        // Toggle high score board visibility
        function toggleHighScores() {
            const board = document.getElementById('highScoreBoard');
            const btn = document.getElementById('toggleScoresBtn');

            if (!board || !btn) return;

            if (board.classList.contains('hidden')) {
                board.classList.remove('hidden');
                btn.textContent = 'Hide [H]';
                try {
                    localStorage.setItem('hanoi_scores_visible', 'true');
                } catch (e) {
                    console.warn('Could not save visibility state:', e);
                }
            } else {
                board.classList.add('hidden');
                btn.textContent = 'Show [H]';
                try {
                    localStorage.setItem('hanoi_scores_visible', 'false');
                } catch (e) {
                    console.warn('Could not save visibility state:', e);
                }
            }
        }

        // Initialize high score board visibility from localStorage
        function initHighScoreVisibility() {
            const board = document.getElementById('highScoreBoard');
            const btn = document.getElementById('toggleScoresBtn');

            if (!board || !btn) return;

            try {
                const visible = localStorage.getItem('hanoi_scores_visible');
                // Default to visible if not set
                if (visible === 'false') {
                    board.classList.add('hidden');
                    btn.textContent = 'Show [H]';
                } else {
                    board.classList.remove('hidden');
                    btn.textContent = 'Hide [H]';
                }
            } catch (e) {
                console.warn('Could not load visibility state:', e);
            }
        }

        // Initialize game with specified number of disks
        function initGame(numDisks, syncSelectedCount = true) {
            // Validate disk count
            numDisks = Math.max(3, Math.min(10, numDisks));

            // Reset state
            gameState.towers = [[], [], []];
            gameState.selectedTower = null;
            gameState.moveCount = 0;
            gameState.startTime = null;
            gameState.gameWon = false;
            gameState.diskCount = numDisks;

            // Only sync selected disk count when starting a new game
            if (syncSelectedCount) {
                selectedDiskCount = numDisks;
                updateDiskCountDisplay();
            }

            // Stop timer if running
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
                gameState.timerInterval = null;
            }

            // Place all disks on first tower (largest to smallest)
            for (let i = numDisks; i >= 1; i--) {
                gameState.towers[0].push(i);
            }

            // Update display
            renderGame();
            updateMoveCounter();
            updateTimer();
            showMessage('Press 1, 2, or 3 to select a tower');
        }

        // Render the entire game state to the DOM as ASCII art
        function renderGame() {
            const maxHeight = gameState.diskCount + 3; // Add space for pole above disks

            // Render each tower
            for (let i = 0; i < 3; i++) {
                const towerElement = document.querySelector(`[data-tower="${i}"]`);
                const asciiContainer = towerElement.querySelector('.ascii-tower');

                const lines = [];
                const disks = gameState.towers[i];

                // Calculate empty space above disks
                const emptyLines = maxHeight - disks.length - 1;

                // Add empty pole lines at top
                for (let j = 0; j < emptyLines; j++) {
                    lines.push('    |    ');
                }

                // Render disks from top to bottom (smallest to largest in visual order)
                for (let j = disks.length - 1; j >= 0; j--) {
                    const diskSize = disks[j];
                    const diskString = '█'.repeat(diskSize * 2 + 1);
                    const padding = ' '.repeat(gameState.diskCount - diskSize);
                    lines.push(padding + diskString + padding);
                }

                // Add base with different character
                const baseChars = '▬'.repeat(gameState.diskCount * 2 + 3);
                lines.push(baseChars);

                asciiContainer.textContent = lines.join('\n');

                // Update selection highlight
                if (gameState.selectedTower === i) {
                    towerElement.classList.add('selected');
                } else {
                    towerElement.classList.remove('selected');
                }
            }
        }

        // Handle keyboard input
        function handleKeyPress(event) {
            const key = event.key;

            // Handle new game key
            if (key === 'n' || key === 'N') {
                startNewGame();
                return;
            }

            // Handle disk count increment/decrement
            if (key === '+' || key === '=') {
                incrementDiskCount();
                return;
            }
            if (key === '-' || key === '_') {
                decrementDiskCount();
                return;
            }

            // Handle high score toggle
            if (key === 'h' || key === 'H') {
                toggleHighScores();
                return;
            }

            // Ignore other input if game is won
            if (gameState.gameWon) return;

            // Map keys 1, 2, 3 to tower indices 0, 1, 2
            const towerMap = {'1': 0, '2': 1, '3': 2};

            if (!(key in towerMap)) return;

            const towerIndex = towerMap[key];

            // First selection - choose source tower
            if (gameState.selectedTower === null) {
                // Check if tower has disks
                if (gameState.towers[towerIndex].length === 0) {
                    showError("Can't select an empty tower");
                    return;
                }

                gameState.selectedTower = towerIndex;
                renderGame();
                showMessage(`Tower ${towerIndex + 1} selected. Choose destination tower.`);
            }
            // Second selection - choose destination tower
            else {
                const fromTower = gameState.selectedTower;
                const toTower = towerIndex;

                // Clear selection
                gameState.selectedTower = null;

                // If selecting the same tower, just cancel the selection
                if (fromTower === toTower) {
                    renderGame();
                    showMessage('Press 1, 2, or 3 to select a tower');
                    return;
                }

                // Attempt move
                if (isValidMove(fromTower, toTower)) {
                    moveDisk(fromTower, toTower);
                } else {
                    renderGame();
                }
            }
        }

        // Check if move is valid according to Hanoi rules
        function isValidMove(fromTower, toTower) {
            const fromDisks = gameState.towers[fromTower];
            const toDisks = gameState.towers[toTower];

            // Can't move from empty tower
            if (fromDisks.length === 0) {
                showError("Source tower is empty");
                return false;
            }

            // Get top disk from source tower
            const diskToMove = fromDisks[fromDisks.length - 1];

            // Can always move to empty tower
            if (toDisks.length === 0) {
                return true;
            }

            // Get top disk from destination tower
            const topDiskOnDestination = toDisks[toDisks.length - 1];

            // Can only place smaller disk on larger disk
            if (diskToMove > topDiskOnDestination) {
                showError("Cannot place larger disk on smaller disk");
                return false;
            }

            return true;
        }

        // Move disk from one tower to another
        function moveDisk(fromTower, toTower) {
            // Start timer on first move
            if (gameState.moveCount === 0) {
                startTimer();
            }

            // Remove disk from source
            const disk = gameState.towers[fromTower].pop();

            // Add disk to destination
            gameState.towers[toTower].push(disk);

            // Update move counter
            gameState.moveCount++;
            updateMoveCounter();

            // Re-render game
            renderGame();

            // Check for win
            if (checkWin()) {
                handleWin();
            } else {
                showMessage('Press 1, 2, or 3 to select a tower');
            }
        }

        // Check if player has won
        function checkWin() {
            // Win condition: all disks on tower 2 (index 2)
            return gameState.towers[2].length === gameState.diskCount;
        }

        // Handle win state
        function handleWin() {
            gameState.gameWon = true;

            // Stop timer
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
                gameState.timerInterval = null;
            }

            // Calculate time
            const elapsedSeconds = Math.floor((Date.now() - gameState.startTime) / 1000);
            const minutes = String(Math.floor(elapsedSeconds / 60)).padStart(2, '0');
            const seconds = String(elapsedSeconds % 60).padStart(2, '0');

            // Check and save high score
            const result = checkAndSaveHighScore(gameState.diskCount, gameState.moveCount, elapsedSeconds);

            // Build win message based on result
            let message = `YOU WIN! Time: ${minutes}:${seconds} | Moves: ${gameState.moveCount}`;
            let messageClass = 'win';

            if (result.type === 'perfect') {
                message += ' | PERFECT SCORE!';
                messageClass = 'perfect';
            } else if (result.type === 'moves') {
                message += ' | NEW RECORD!';
                messageClass = 'record';
            } else if (result.type === 'time') {
                message += ' | FASTER TIME!';
                messageClass = 'record';
            } else if (result.type === 'first') {
                message += ' | FIRST COMPLETION!';
                messageClass = 'record';
            } else if (result.isPerfect) {
                message += ' | PERFECT SCORE!';
                messageClass = 'perfect';
            }

            const messageEl = document.getElementById('message');
            messageEl.textContent = message;
            messageEl.className = `message ${messageClass}`;
        }

        // Start the game timer
        function startTimer() {
            gameState.startTime = Date.now();
            gameState.timerInterval = setInterval(updateTimer, 1000);
        }

        // Update timer display
        function updateTimer() {
            let elapsedSeconds = 0;

            if (gameState.startTime) {
                elapsedSeconds = Math.floor((Date.now() - gameState.startTime) / 1000);
            }

            const minutes = String(Math.floor(elapsedSeconds / 60)).padStart(2, '0');
            const seconds = String(elapsedSeconds % 60).padStart(2, '0');

            document.getElementById('timer').textContent = `TIME: ${minutes}:${seconds}`;
        }

        // Update move counter display
        function updateMoveCounter() {
            document.getElementById('moveCounter').textContent = `MOVES: ${gameState.moveCount}`;
        }

        // Show normal message
        function showMessage(text) {
            const messageEl = document.getElementById('message');
            messageEl.textContent = text;
            messageEl.className = 'message';
        }

        // Show error message
        function showError(text) {
            const messageEl = document.getElementById('message');
            messageEl.textContent = text;
            messageEl.className = 'message error';
        }

        // Show win message
        function showWinMessage(text) {
            const messageEl = document.getElementById('message');
            messageEl.textContent = text;
            messageEl.className = 'message win';
        }

        // Increment selected disk count
        function incrementDiskCount() {
            if (selectedDiskCount < 10) {
                selectedDiskCount++;
                updateDiskCountDisplay();
            }
        }

        // Decrement selected disk count
        function decrementDiskCount() {
            if (selectedDiskCount > 3) {
                selectedDiskCount--;
                updateDiskCountDisplay();
            }
        }

        // Update disk count display
        function updateDiskCountDisplay() {
            document.getElementById('diskCountDisplay').textContent = selectedDiskCount;
        }

        // Start new game with selected disk count
        function startNewGame() {
            initGame(selectedDiskCount, true);
        }

        // Event listeners
        document.addEventListener('keypress', handleKeyPress);
        document.getElementById('newGameBtn').addEventListener('click', startNewGame);
        document.getElementById('incrementBtn').addEventListener('click', incrementDiskCount);
        document.getElementById('decrementBtn').addEventListener('click', decrementDiskCount);
        document.getElementById('toggleScoresBtn').addEventListener('click', toggleHighScores);
        document.getElementById('clearScoresBtn').addEventListener('click', clearHighScores);

        // Initialize game and high scores on page load
        initGame(5);
        renderHighScores();
        initHighScoreVisibility();
    </script>
</body>
</html>
